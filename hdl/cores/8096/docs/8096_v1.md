# 8096 CPU v1.0 (P0 8086 + P7 native scaffold)

## Overview

`cpu_8096` is an in-order, fabric-attached x86-family core intended to be feasible in simple logic. v1.0 focuses on a **functional** 8086-compatible subset (P0) plus a gated **P7 native** extension page.

## Tier ladder and mode switching

- Tier ladder: `CARBON_X86_DERIVED_TIER_P0_I8086_8087` .. `CARBON_X86_DERIVED_TIER_P7_X86_64`
- v1.0 supports:
  - **P0**: implemented
  - **P7**: implemented (native extensions gated; see below)
  - **P1â€“P6**: **trap if entered** (not implemented)

Mode switching follows the canonical MODEUP/RETMD contract (see `hdl/spec/mode_switch.yaml`) but is exposed as **Carbon-only opcodes** (not legacy 8086 opcodes):

- `0x62 0x00 <target_tier:u8> <entry_ip:u16>`: `MODEUP(target_tier, entry_ip)`
- `0x62 0x01`: `RETMD()`

Notes:
- `entry_ip` is a 16-bit offset within the current `CS` (no far/segment entry vector in v1).
- A modestack frame stores `{previous_tier, previous_modeflags, return_ip}`.
- Prefetch state is flushed on mode transitions.

## MODEFLAGS / extension gating

Extension access is gated by:

`ext_allowed = (tier == P7) && (MODEFLAG_STRICT == 0)`

`MODEFLAG_STRICT` uses the generated bit position/mask from `hdl/gen/carbon_arch_pkg.sv` and is writable via `CARBON_CSR_MODEFLAGS` (privileged).

## Native extension page (P7-only)

Extension instructions use a **Carbon-only prefix** `0x63` and trap unless `ext_allowed` is true.

Extension register file:
- `R0..R15` (16-bit), internal only in v1.

Implemented extension sub-ops:
- `0x63 0x00 <treg:u8> <imm16:u16>`: `MOVX treg, imm16`
- `0x63 0x01 <treg:u8> <reg:u8>`: `MOVX treg, reg16` (legacy reg index in low 3 bits)
- `0x63 0x02 <treg:u8> <reg:u8>`: `MOVX reg16, treg`
- `0x63 0x10 <dst_treg:u8> <src_treg:u8>`: `ALUX_ADD dst, src` (updates flags like `ADD`)

## Memory model

- Real-mode segmentation: `phys = ((segment << 4) + offset) & 20'hFFFFF`
- Little-endian loads/stores.
- Default segment selection:
  - `SS` for stack accesses and BP-based addressing forms
  - `DS` otherwise

## Implemented 8086 subset (v1.0)

Instruction fetch is functional and uses an internal (demand-filled) **prefetch queue**.

Implemented:
- `NOP` (`0x90`)
- `HLT` (`0xF4`) (halts; cleared via `dbg.run_req` or CSR debug control)
- `MOV reg16, imm16` (`0xB8..0xBF`)
- ModRM-based:
  - `MOV r/m16, r16` (`0x89`)
  - `MOV r16, r/m16` (`0x8B`)
  - `ADD/SUB/CMP` (`0x01/0x03`, `0x29/0x2B`, `0x39/0x3B`)
  - `AND/OR/XOR/TEST` (`0x21/0x23`, `0x09/0x0B`, `0x31/0x33`, `0x85`)
  - `MOV r/m16, Sreg` (`0x8C`) and `MOV Sreg, r/m16` (`0x8E`) (CS moves are not cycle-accurate; see TODO)
- `INC/DEC reg16` (`0x40..0x4F`)
- `PUSH/POP reg16` (`0x50..0x5F`)
- `PUSH/POP` segment regs (subset): `ES/SS/DS` pops; `ES/CS/SS/DS` pushes
- Control flow:
  - `Jcc rel8` (`0x70..0x7F`)
  - `JMP rel8` (`0xEB`)
  - `JMP rel16` (`0xE9`)
  - `CALL rel16` (`0xE8`)
  - `RET` (`0xC3`)
- `INT imm8` (`0xCD`) stub: traps with cause `X96_CAUSE_INTN | imm8`
- `REP` (`0xF3`) with `MOVS`/`STOS` (`0xA4/0xA5/0xAA/0xAB`) as a simple micro-loop

## CSR / debug

Implements a minimal set of core-common CSRs:
- `CARBON_CSR_ID`, `CARBON_CSR_MODEFLAGS`, `CARBON_CSR_TIME`, `CARBON_CSR_TIME_HI`, `CARBON_CSR_CAUSE`, `CARBON_CSR_EPC`
- Debug CSRs: `CARBON_CSR_DBG_CTRL`, `CARBON_CSR_DBG_STEP`, `CARBON_CSR_DBG_STATUS`

Notes:
- `CARBON_CSR_TIER` is read-only in v1 and reflects the current tier.

## Deferred / not implemented yet

- Full 8086 ISA coverage (shifts/rotates, MUL/DIV, far calls/jumps, string variants beyond MOVS/STOS semantics, etc.)
- Segment override prefixes (`ES:`/`CS:`/`SS:`/`DS:`)
- DF handling for string ops (v1 assumes `DF=0`)
- Hardware interrupt delivery and real `INT` vector behavior (push FLAGS/CS/IP + vector fetch)
- I/O instructions (`IN`/`OUT`) and use of the `io_if` fabric port
- Accurate 8086 micro-timing and prefetch side effects (v1 is functional only)
- Integrated 8097 coprocessor instruction path (see 8097 docs; v1 treats it as a separate unit)
