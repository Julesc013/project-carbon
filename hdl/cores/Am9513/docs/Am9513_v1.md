# Am9513 Accelerator v1.0 (Project Carbon)

This document describes the **Am9513 v1.0** fabric-attached accelerator implementation in `hdl/cores/Am9513/`.

## 1. Mode personalities

Am9513 exposes three personalities:

- **P0 (am9511 compatibility)**: CSR-driven legacy stack/command model (functional compatibility, not cycle-accurate bus behavior).
- **P1 (am9512 compatibility)**: CSR-driven legacy command model with IEEE-ish `binary32`/`binary64` selection.
- **P7 (am9513 turbo)**: Native CAI submission/completion, multi-context execution, register-file fast path.

### Selection rules

- **CSR default personality** is set by `CARBON_CSR_AM9513_MODE` and applies to non-CAI paths and to CAI when the descriptor does not override the mode.
- **Per-descriptor override** uses `submit_desc.flags[AM9513_SUBMIT_FLAG_MODE_VALID_BIT]` with `submit_desc.flags[AM9513_SUBMIT_FLAG_MODE_LSB +: AM9513_SUBMIT_FLAG_MODE_WIDTH]`.

Legacy mode behavior is intended to remain stable across Am9513 revisions; the turbo path may grow features over time.

## 2. Supported formats

Implemented numeric formats (IDs from `hdl/gen/carbon_arch_pkg.sv`):

- `CARBON_FMT_BINARY16` (IEEE 754 half)
- `CARBON_FMT_BFLOAT16`
- `CARBON_FMT_BINARY32` (IEEE 754 binary32-ish)
- `CARBON_FMT_BINARY64` (IEEE 754 binary64-ish)

Deferred:

- Decimal formats (explicitly **not** implemented in v1.0).

## 3. Per-context IEEE environment

Each context contains:

- **Rounding mode** (`RN/RZ/RP/RM`) stored per-context.
- **Sticky exception flags** (per-context):
  - `NV` invalid
  - `DZ` divide-by-zero
  - `OF` overflow
  - `UF` underflow
  - `NX` inexact

v1.0 does **not** implement exception traps/masks; operations only **set** flags (sticky OR) and never trap.

CSR access (selected by `CARBON_CSR_AM9513_CTX_SEL`):

- `CARBON_CSR_AM9513_CTX_RM` read/write rounding mode.
- `CARBON_CSR_AM9513_CTX_FLAGS` read flags.
- `CARBON_CSR_AM9513_CTX_FLAGS_CLR` write-1-to-clear flags.

## 4. Context model

Am9513 v1.0 implements a parameterized number of contexts (default **64**, minimum supported for v1 is **16**).

Per-context state:

- IEEE environment (rounding + sticky flags).
- **Register file** `F0..F15` (64-bit storage; `binary16/bfloat16/binary32` values occupy low bits).
- Legacy compatibility stack (depth parameterized, default 16 entries).

CSR register-file access:

- Select register index via `CARBON_CSR_AM9513_RF_INDEX`.
- Read/write via `CARBON_CSR_AM9513_RF_DATA_LO` / `CARBON_CSR_AM9513_RF_DATA_HI` (writes commit on `RF_DATA_HI` write).

## 5. CAI integration (turbo path)

### Submission

Am9513 uses the standard CAI ring model (`hdl/spec/cai.yaml`):

- Host writes submission descriptors into a memory-backed ring and pulses `cai.submit_doorbell`.
- v1.0 processes descriptors **in order**, with **single-outstanding** fabric access (simple micro-engine) and a bounded pending counter.
- Software must ensure descriptor stores are globally visible before ringing the doorbell (fence on weakly-ordered systems).

Context selection:

- If `submit_desc.context_id == 0xFFFF`, Am9513 uses `cai.context_sel`.
- Otherwise the descriptor’s `context_id` selects the context.

### Completion

Completions are written to a memory-backed ring whose base/mask are configured via CSRs:

- `CARBON_CSR_AM9513_CAI_COMP_BASE_LO/HI`
- `CARBON_CSR_AM9513_CAI_COMP_RING_MASK`
- `CARBON_CSR_AM9513_CAI_IRQ_ENABLE`

Completion record (`CAI_COMP_REC_V1`) fields:

- `tag`: copied from submission descriptor.
- `status`: `CARBON_CAI_STATUS_*`.
- `ext_status`: low bits carry Am9513 exception flags (NV/DZ/OF/UF/NX).
- `bytes_written`: number of bytes written to the result buffer (0 on fault / regfile-fastpath).

### Opcode encoding

Am9513 uses vendor opcode space:

- `opcode[31] = 1`
- `opcode[15:8] = dst_format` (one of `CARBON_FMT_*`)
- `opcode[7:0]  = function` (Am9513 function selector)

Conversions:

- Use `function = AM9513_FUNC_CONV`.
- `opcode[15:8]` is destination format, and `submit_desc.flags[7:0]` is source format.

Integer conversions (v1.0):

- `AM9513_FUNC_I32_TO_F32` (`fmt=binary32`): operand0 int32 → `binary32`
- `AM9513_FUNC_F32_TO_I32` (`fmt=binary32`): operand0 `binary32` → int32
- `AM9513_FUNC_I64_TO_F64` (`fmt=binary64`): operand0 int64 → `binary64`
- `AM9513_FUNC_F64_TO_I64` (`fmt=binary64`): operand0 `binary64` → int64

On overflow/NaN, float→int saturates and sets `NV` (and sets `NX` when inexact).

Multi-result operations:

- `AM9513_FUNC_SINCOS` writes two results:
  - result0 at `result_ptr`
  - result1 at `result_ptr + (result_stride != 0 ? result_stride : elem_bytes)`

### Register-file fast path (P7)

Turbo mode supports a fast path to write the primary result into `F0..F15`:

- `submit_desc.flags[AM9513_SUBMIT_FLAG_RESULT_REG_BIT]` enables result-to-reg.
- `submit_desc.flags[AM9513_SUBMIT_FLAG_RESULT_REG_LSB +: AM9513_SUBMIT_FLAG_RESULT_REG_WIDTH]` selects destination register.

v1.0 fast path writes **only res0** (for multi-result ops, res1 is not written to the RF).

## 6. Legacy compatibility shells (CSR)

Legacy access is a functional (not timing-accurate) command/stack interface:

- Push operands by writing `LEGACY_PUSH_LO` then `LEGACY_PUSH_HI` (the `PUSH_HI` write commits the push).
- Pop results by reading `LEGACY_POP_LO` then `LEGACY_POP_HI` (the `POP_HI` read commits the pop).
- Issue an operation by writing `CARBON_CSR_AM9513_LEGACY_OP` with a legacy opcode.

Mode selection:

- `CARBON_CSR_AM9513_LEGACY_CTRL[0] = 0` selects 9511-style behavior (default `binary32`).
- `CARBON_CSR_AM9513_LEGACY_CTRL[0] = 1` selects 9512-style behavior (supports `binary32`/`binary64` selection).
- `CARBON_CSR_AM9513_LEGACY_CTRL[7:4]` may be used to request a format; v1.0 treats any non-`binary32` request as `binary64` when in 9512 mode.

`CARBON_CSR_AM9513_LEGACY_STATUS` provides busy and basic stack depth status.

## 7. Accuracy policy (v1.0)

v1.0 prioritizes determinism and synthesizability:

- Not correctly-rounded; implements a **bounded-error** policy for transcendentals.
- Transcendentals use small polynomial-style approximations (implementation-defined).
- `binary64` transcendentals are computed via `binary32` approximation and up-converted (deterministic, reduced accuracy).
- Subnormals may be flushed-to-zero in fast paths.

## 8. Deferred / TODO (explicitly not implemented)

- Decimal floating-point formats.
- Full IEEE 754 edge-case conformance (NaN payload rules, signed-zero nuances, totalOrder, full compare semantics).
- Correctly-rounded transcendentals.
- Exception traps/masks (flags only, no trapping).
- Vector/stride semantics for operand/result arrays beyond the scalar v1 behavior.
- Multiple outstanding descriptor fetches / deeper pipelining.
