# Z85 v1.0 — Strict Z80 Engine (Core Contract)

## Scope

Z85 is Project Carbon’s **strict Z80-compatible** CPU core. It is intended to be correctness-first and easy to realize using simple FSM/microcode style logic.

Z85 targets the **Z80-derived compatibility ladder**:

- P0: 8080
- P1: 8085
- P2: Z80
- P3+: not implemented in Z85 (must illegal-trap)

Z85 does **not** implement system-level peripherals, banking/MMU, or bus pin timing. It is a **core**, not a system.

## “Undocumented” policy

Z85 is required to behave like “real Z80” including widely-used undocumented behavior:

- Undocumented `SLL` in the `CB` group
- IXH/IXL and IYH/IYL register forms via `DD/FD` prefixes where applicable
- X/Y flags (bits 3 & 5) propagated in the conventional Z80 way for supported ops

## Illegal opcode policy

- Any opcode outside the implemented Z80 set is **illegal-trapped**.
- Trap is latched internally and exposed via:
  - `CARBON_CSR_CAUSE`
  - `CARBON_CSR_EPC`
- Trap return is **not implemented** in v1; reset is required to clear the trap latch.

## Interrupt sampling policy

Z85 samples interrupts only at **instruction boundaries**.

### irq_if encoding

Z85 uses a single `irq_if` for INT + NMI:

- If `irq_vector` width is **> 8**, the MSB is treated as **NMI indicator**.
- The low 8 bits `irq_vector[7:0]` are the **interrupt “byte”**:
  - In **IM2**, this is the IM2 vector byte.
  - In **IM0**, this is the bus-supplied instruction byte.

### IM0 policy

Full IM0 “execute arbitrary bus-supplied instruction stream” is not implemented in v1.

v1 supports only **RST opcode bytes** in IM0; otherwise it traps with `Z85_CAUSE_IM0_UNSUP`.

## Memory and I/O ordering policy

Z85 produces bus transactions through `fabric_if`:

- `mem_if`: memory transactions
- `io_if`: I/O transactions

Properties:

- One outstanding transaction at a time (v1 simplification)
- I/O requests are marked `ORDERED` and `IO_SPACE` via generated fabric attribute masks

## R register policy

Z85 increments the refresh register `R[6:0]` on each **opcode/prefix fetch** (approximation):

- increments for prefix bytes (`DD/FD/ED/CB`) and the final opcode byte
- does **not** increment for displacement or immediate data bytes

## What is NOT implemented yet

The current RTL is scaffolding and does not yet implement the full Z80 instruction set required by the Z85 v1.0 target:

- Many base opcodes and most ED-prefixed instructions
- Full IM0 semantics and full NMI return (`RETN`) behavior
- Full block instructions (LDIR/CPIR/INIR/OTIR/etc.)
- Full undocumented flag quirks for all Z80 instructions

