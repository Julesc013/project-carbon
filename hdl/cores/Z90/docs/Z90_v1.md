# Z90 v1.0 (Scaffolding) — Z80 Successor Core

This directory contains the initial Z90 core scaffolding for Project Carbon. It is intended to integrate the common fabric/CSR/debug/CAI infrastructure and freeze the Z90 fast-path opcode-page contract via generated constants.

## Architectural intent

- **Compatibility**: Z90 is intended to execute all Z85 legacy instructions unchanged in legacy tiers (P0–P3). This scaffolding currently implements only a small 8080-compatible subset needed for basic bring-up tests.
- **Z90 fast-path ISA**: New instructions live in **Z90 opcode pages** defined in `hdl/spec/isa_z90.yaml` and generated into `hdl/gen/carbon_arch_pkg.sv`.
- **Fast-path gating**: This implementation treats Z90 fast-path instructions as gated features:
  - Allowed only when `CSR_TIER == CARBON_Z80_DERIVED_TIER_P7_Z480` **and** `MODEFLAG_STRICT==0`.
  - `MODEUP`/`RETMD` are always legal (so boot code can upgrade tiers).

## Register file

- **Legacy state**: A Z80-like register file (implemented using `z85_state_t`) is present for the legacy subset.
- **Z90 state**:
  - `X0..X15` are **16-bit** registers.
  - `X0` reads as zero; writes are ignored (recommended ABI practice).
  - `Z90 FLAGS` are separate from Z80 `F` and are currently minimal:
    - `Z` (zero), `S` (sign), `C` (carry/borrow), `V` (overflow). See `hdl/cores/Z90/rtl/z90_alu_pkg.sv`.

Recommended ABI (informational):
- `X14 = FP`
- `X15 = SPX`

## Instruction encoding overview (generated contract)

Z90 opcode pages are entered by an `ED` escape plus a page selector byte:
- Page0 prefix: `CARBON_Z90_OPPAGE_P0_PREFIX0/1` (default `ED F0`)
- Page1 prefix: `CARBON_Z90_OPPAGE_P1_PREFIX0/1` (default `ED F1`)

Page0 format (after prefix):
- `op0 = {major[7:4], rd[3:0]}`
- `op1 = {sub[7:4], rs[3:0]}`

Page1 format (after prefix):
- `op0 = {major[7:4], rd[3:0]}`
- `op1 = {base[7:4], index[3:0]}`
- `disp8` signed displacement

## MODEUP / RETMD

Implements the canonical contract from `hdl/spec/mode_switch.yaml`:
- `MODEUP(target_tier_u8, entry_u16)` pushes `(prev_tier, prev_modeflags, return_pc)` and jumps to `entry_u16`.
- `RETMD()` pops and restores tier/modeflags/PC; traps on underflow.

Mode stack depth is parameterized by `MODESTACK_DEPTH` and must be >= `CARBON_MODESTACK_MIN_DEPTH`.

## Atomics

This scaffolding implements a single atomic model:
- **CAS16** via `fabric_if` atomic transactions (`CARBON_FABRIC_XACT_ATOMIC`)
- Payload encoding (scaffolding contract between core and fabric slave/BFM):
  - `req_wdata[15:0] = expected`
  - `req_wdata[31:16] = desired`
  - `rsp_rdata[15:0] = old`
  - `rsp_rdata[31] = success` (optional convenience bit in the simulation BFM)

Atomic enable hook:
- `CSR_Z90_ATOMIC_CTL[0]` gates CAS16 (enabled by default in this scaffolding).

## CAI (Carbon Accelerator Interface)

`CAI_CFG` and `CAI_SUBMIT` are implemented as simple scaffolding operations:
- `CAI_CFG` maps fixed X registers into `cai_if` host registers:
  - `submit_desc_base = {X3, X2}` (32-bit, zero-extended to 64)
  - `comp_base = {X5, X4}` (32-bit, zero-extended to 64)
  - `submit_ring_mask = X6[15:0]`
  - `context_sel = X7[15:0]`
- `CAI_SUBMIT` pulses `submit_doorbell` for 1 cycle.

## What is explicitly NOT implemented yet

- Full Z85 legacy ISA (including undocumented Z80 behaviors) and full legacy tier strictness.
- Z90 immediate forms, full load/store widths, control-flow ops, REP/string ops, and complete flag semantics.
- Interrupt/NMI semantics, `irq_if` delivery, and trap/exception vectoring.
- Architectural CSR access instructions (CSRs are only accessible via `csr_if` in this scaffolding).
- Cache/MMU/VM behavior (register-only placeholders exist via `CSR_Z90_*`).
